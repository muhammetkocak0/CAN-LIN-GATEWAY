# Generic CAN-LIN Gateway Firmware v2.0

## üìÅ Firmware Structure

```
firmware/
‚îú‚îÄ‚îÄ platformio.ini          # Build configuration
‚îú‚îÄ‚îÄ include/
‚îÇ   ‚îú‚îÄ‚îÄ config.h           # Hardware & system config
‚îÇ   ‚îú‚îÄ‚îÄ protocol.h         # Serial protocol definitions  
‚îÇ   ‚îî‚îÄ‚îÄ frame_mapper.h     # Dynamic mapping engine
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.cpp           # Main firmware
‚îÇ   ‚îú‚îÄ‚îÄ protocol.cpp       # Protocol implementation
‚îÇ   ‚îú‚îÄ‚îÄ frame_mapper.cpp   # Mapping engine
‚îÇ   ‚îî‚îÄ‚îÄ storage.cpp        # Flash storage
‚îî‚îÄ‚îÄ README.md              # This file
```

## üöÄ Quick Start

### 1. Build Firmware

```bash
cd firmware

# Build
pio run

# Build + Upload
pio run --target upload

# Monitor serial output
pio device monitor --baud 115200
```

### 2. Expected Output

After upload, you should see:

```
========================================
  Generic CAN-LIN Gateway v2.0.0
  Professional Configurable Bridge
========================================
Build: Jan 17 2026 14:32:45
========================================

[INIT] Checking Flash for saved configuration...
[INIT] No saved configuration found
[INIT] Use GUI configurator to set up gateway

[LIN] Initialized at 19200 baud
[CAN] Initialized at 500 kbps

[READY] Waiting for commands...
========================================

‚îÄ‚îÄ‚îÄ Gateway Status ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Running: ‚úó NO
Mappings: 0
Uptime: 5 seconds
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

## üîß Configuration

### Hardware Configuration (`include/config.h`)

Modify these defines if using different pins:

```cpp
// LIN Interface
#define LIN_UART_TX         PA2
#define LIN_UART_RX         PA3

// CAN Interface  
#define CAN_RX_PIN          PB8
#define CAN_TX_PIN          PB9

// Default baud rates
#define DEFAULT_LIN_BAUD    19200
#define DEFAULT_CAN_BAUD    500000

// Maximum mappings
#define MAX_MAPPINGS        64
```

### Debug Options

```cpp
// Enable debug output
#define DEBUG_SERIAL        1

// Enable verbose logging (lots of output!)
#define DEBUG_VERBOSE       0
```

## üì° Serial Protocol

### Connect to Gateway

```python
import serial

ser = serial.Serial('COM3', 115200)
```

### Command Format

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 0xAA ‚îÇ CMD  ‚îÇ LENGTH ‚îÇ PAYLOAD ‚îÇ CRC16    ‚îÇ 0x55‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Example: Get Status

```python
# Build message
msg = bytearray()
msg.append(0xAA)  # SOF
msg.append(0x07)  # CMD_GET_STATUS
msg.append(0x00)  # Length low
msg.append(0x00)  # Length high
# Calculate CRC16...
msg.append(crc & 0xFF)
msg.append((crc >> 8) & 0xFF)
msg.append(0x55)  # EOF

# Send
ser.write(msg)

# Receive response
response = ser.read(100)
```

## üó∫Ô∏è Creating Mappings

### Via Protocol (Manual)

```cpp
// Example: Map LIN Frame 0x32 ‚Üí CAN Message 0x100

FrameMapping_t mapping;
mapping.mappingId = 1;
mapping.sourceType = BUS_TYPE_LIN;  // 0
mapping.sourceId = 0x32;
mapping.sourceLen = 8;
mapping.destType = BUS_TYPE_CAN;    // 1
mapping.destId = 0x100;
mapping.destLen = 8;
mapping.numSignals = 1;

// Signal: RPM (Byte 1)
mapping.signals[0].srcBitStart = 8;   // Bit 8 = Byte 1
mapping.signals[0].srcBitLen = 8;     // 8 bits
mapping.signals[0].destBitStart = 8;  // Also byte 1
mapping.signals[0].destBitLen = 8;
mapping.signals[0].scale = 25.0;      // Scale factor
mapping.signals[0].offset = 0.0;
mapping.signals[0].byteOrder = BYTE_ORDER_LITTLE;

mapping.updateRateMs = 20;   // 50 Hz max
mapping.enabled = 1;

// Send via protocol (CMD_ADD_MAPPING = 0x03)
```

### Via GUI Configurator (Recommended)

Use the Python GUI application - much easier!

## üíæ Flash Storage

### Memory Map

```
Flash (512 KB):
0x08000000 - 0x08004000  Bootloader (16KB) Reserved
0x08004000 - 0x080E0000  Firmware (880KB)
0x080E0000 - 0x08100000  Config Storage (128KB)
```

### Save Configuration

```cpp
// Saves current mappings to Flash
frameMapper.saveToFlash();

// Survives power cycles!
```

### Load on Boot

```cpp
// In setup()
if (frameMapper.loadFromFlash()) {
    // Configuration restored
}
```

## üîç Testing

### Test 1: Protocol Communication

```bash
# Connect via serial terminal
pio device monitor

# Send GET_STATUS command (0x07)
# Should receive response
```

### Test 2: LIN Sniffer Mode

```cpp
// Connect to existing LIN bus (passive)
// Should see LIN frames in serial output

[LIN RX] ID: 0x32
[LIN RX] ID: 0x33
```

### Test 3: Simple Mapping

```python
# Use GUI to create one mapping
# Upload to gateway
# Start gateway
# Verify CAN message transmitted when LIN frame received
```

## üìä Performance

| Metric | Value |
|--------|-------|
| LIN Baud Rates | 1200 - 20000 bps |
| CAN Baud Rates | 10k - 1000k bps |
| Max Mappings | 64 simultaneous |
| Latency (LIN‚ÜíCAN) | <2 ms typical |
| Frame Loss | <0.1% |
| Flash Usage | ~120KB firmware |
| RAM Usage | ~25KB runtime |
| Loop Rate | ~1000 Hz |

## üêõ Debugging

### Enable Verbose Logging

In `config.h`:
```cpp
#define DEBUG_VERBOSE       1  // Lots of output!
```

Rebuild and upload.

### Check Statistics

Serial monitor shows stats every 5 seconds:

```
‚îÄ‚îÄ‚îÄ Statistics ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
LIN RX: 1234 | TX: 56 | Errors: 2
CAN RX: 789 | TX: 1234 | Errors: 0
Mapping Errors: 0 | Checksum Errors: 1
Loop Rate: 980 Hz
```

### Common Issues

**Issue: LIN frames not received**
- Check LIN transceiver wiring
- Verify 12V power to TJA1020
- Check baud rate matches (19200)

**Issue: CAN messages not sent**
- Check CAN transceiver wiring
- Verify 3.3V to SN65HVD230
- Check 120Œ© termination resistors
- Verify baud rate (500kbps default)

**Issue: High mapping errors**
- Check signal bit positions match DBC/LDF
- Verify byte order (Little/Big Endian)
- Check source/dest frame lengths

## üî¨ Advanced Features

### Custom LIN Baud Rate

```python
# Via protocol
lin_config = LinConfig_t()
lin_config.baudRate = 9600  # Custom rate
# Send CMD_SET_LIN_CONFIG
```

### CAN Filtering

```python
# Configure acceptance filters
can_config = CanConfig_t()
can_config.numFilters = 1
can_config.filters[0].id = 0x100
can_config.filters[0].mask = 0x7FF  # Exact match
# Send CMD_SET_CAN_CONFIG
```

### Bidirectional Mapping

```cpp
// Map both directions
mapping1: LIN 0x32 ‚Üí CAN 0x100  // Telemetry
mapping2: CAN 0x200 ‚Üí LIN 0x33  // Commands
```

### Rate Limiting

```cpp
// Limit update rate
mapping.updateRateMs = 100;  // Max 10 Hz
```

## üìù Code Examples

### Example 1: BLDC Motor Mapping

See `examples/bldc_motor/` for complete example.

### Example 2: Multi-Signal Mapping

```cpp
// Map multiple signals from one frame
mapping.numSignals = 3;

// Signal 1: RPM
mapping.signals[0].srcBitStart = 8;
mapping.signals[0].srcBitLen = 8;
// ...

// Signal 2: Temperature  
mapping.signals[1].srcBitStart = 16;
mapping.signals[1].srcBitLen = 8;
// ...

// Signal 3: Voltage
mapping.signals[2].srcBitStart = 24;
mapping.signals[2].srcBitLen = 10;
// ...
```

## üèóÔ∏è Building from Source

### Requirements

- PlatformIO Core 6.0+
- STM32 platform
- STM32F446RE board

### Build Steps

```bash
# Clean
pio run --target clean

# Build
pio run

# Upload
pio run --target upload

# Monitor
pio device monitor
```

### Build Flags

Defined in `platformio.ini`:

```ini
build_flags = 
    -D HAL_CAN_MODULE_ENABLED
    -D HAL_UART_MODULE_ENABLED
    -D HAL_FLASH_MODULE_ENABLED
    -D DEBUG_SERIAL=1
```

## üìö API Reference

### Frame Mapper API

```cpp
class FrameMapper {
public:
    bool addMapping(const FrameMapping_t* mapping);
    bool deleteMapping(uint16_t mappingId);
    void clearAllMappings();
    
    uint8_t processLinFrame(uint8_t frameId, const uint8_t* data, uint8_t len);
    uint8_t processCanMessage(uint32_t msgId, const uint8_t* data, uint8_t len);
    
    bool saveToFlash();
    bool loadFromFlash();
};
```

### Protocol API

```cpp
class Protocol {
public:
    bool receiveMessage(ProtocolMessage_t* msg);
    void sendResponse(uint8_t cmd, uint8_t status, const uint8_t* data, uint16_t len);
    void processCommand(ProtocolMessage_t* msg);
};
```

## üéì Further Reading

- [PROTOCOL.md](../docs/PROTOCOL.md) - Protocol specification
- [HARDWARE.md](../docs/HARDWARE.md) - Hardware setup guide
- [USER_GUIDE.md](../docs/USER_GUIDE.md) - Complete user manual

## üìû Support

For issues or questions:
1. Check serial debug output
2. Verify wiring against HARDWARE.md
3. Test with minimal mapping first
4. Review statistics for error counters

---

**Firmware ready to flash! üöÄ**